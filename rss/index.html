<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[白袍君]]></title><description><![CDATA[I'm a RD Engineer & life Saver .  This blog about My Thoughts, stories and ideas etc.    Make sth happen , 记录生活 , 日进一步]]></description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Thu, 04 Feb 2016 03:30:54 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[How to Get Startup Ideas!（上半部）]]></title><description><![CDATA[<p>之前收藏了一篇老外（国外YC大咖）的文章，整理资料的时候无意中看到了，觉得不错，然后决定自己尝试翻译过来，加上自己的理解，链接<a href="http://localhost:2368/how-to-get-startup-ideas-xiao-zong-jie/[http://paulgraham.com/startupideas.html">How to Get StartUp ideas!</a>,水平有限，收获很多，开始了：</p>

<ul>
<li>获得好的点子不是成天去想点子，而是寻找问题，更偏向于你所具有的问题本身</li>
<li>绝佳的点子通常有三个基本属性：首先是这件事是创始人想要的，其二他们自己可以建立，其三除了创始人以外还有人认为这件事是值得做的，像微软、苹果、雅虎、谷歌、FaceBook全都是以这种方式开始的</li>
</ul>

<p><strong>分以下几个维度来描述：</strong></p>

<p><strong>1.应当注意的麻烦或者说问题（problem）</strong></p>

<p>时间花费在一个已有的问题上很重要，为什么？在所有的繁杂的事情中，确保问题是否真的存在。听起来已显而易见了，应该把时间花费在确实存在的问题上了。在过去的一段时间里普遍的创业者所做的是花费时间去解决实际上不存在的问题上。</p>

<p>我领悟到这些的时候，在1995年，我做了一家公司业务是把画廊放在网上。但是实际上画廊不想放在网上，这不是画廊的业务模式。所以意识到我为什么花费6个月的时间工作在这个愚蠢的idea上呢？因为我没有注意力放在用户身上.捏造了一个与现实并不匹配的世界模型，并且还是从虚拟世界开始寄建立。直到尝试努力使用户信服在我所建立的模型上进行支付时，才意识到我的模型是错误的。</p>]]></description><link>http://localhost:2368/how-to-get-startup-ideas-xiao-zong-jie/</link><guid isPermaLink="false">04542625-f019-45a2-9552-d1f4fe97e098</guid><dc:creator><![CDATA[Wilbur]]></dc:creator><pubDate>Thu, 04 Feb 2016 02:56:52 GMT</pubDate><content:encoded><![CDATA[<p>之前收藏了一篇老外（国外YC大咖）的文章，整理资料的时候无意中看到了，觉得不错，然后决定自己尝试翻译过来，加上自己的理解，链接<a href="http://localhost:2368/how-to-get-startup-ideas-xiao-zong-jie/[http://paulgraham.com/startupideas.html">How to Get StartUp ideas!</a>,水平有限，收获很多，开始了：</p>

<ul>
<li>获得好的点子不是成天去想点子，而是寻找问题，更偏向于你所具有的问题本身</li>
<li>绝佳的点子通常有三个基本属性：首先是这件事是创始人想要的，其二他们自己可以建立，其三除了创始人以外还有人认为这件事是值得做的，像微软、苹果、雅虎、谷歌、FaceBook全都是以这种方式开始的</li>
</ul>

<p><strong>分以下几个维度来描述：</strong></p>

<p><strong>1.应当注意的麻烦或者说问题（problem）</strong></p>

<p>时间花费在一个已有的问题上很重要，为什么？在所有的繁杂的事情中，确保问题是否真的存在。听起来已显而易见了，应该把时间花费在确实存在的问题上了。在过去的一段时间里普遍的创业者所做的是花费时间去解决实际上不存在的问题上。</p>

<p>我领悟到这些的时候，在1995年，我做了一家公司业务是把画廊放在网上。但是实际上画廊不想放在网上，这不是画廊的业务模式。所以意识到我为什么花费6个月的时间工作在这个愚蠢的idea上呢？因为我没有注意力放在用户身上.捏造了一个与现实并不匹配的世界模型，并且还是从虚拟世界开始寄建立。直到尝试努力使用户信服在我所建立的模型上进行支付时，才意识到我的模型是错误的。甚至花费很长的时间才见慢慢理解。</p>

<p>在YC 我们把这些叫做场景Idea 。可以想象一下，在电视剧中的一个角色正在开始startup.这个导演不得不去捏造一些事情做。想到一个好的idea很难，所以脚本写出来的一些idea听起来貌似真实，实际上真的很糟糕。</p>

<p>举个例子，一个针对宠物主的社交网站， 听起来不没有什么错误。有几百万的人养宠物。通常都是特别用心的照顾他们的宠物并且花费了很多的钱在他们身上。理所当然，这里面的大多数都希望有一个他们可以互相交流的网站。获取不需要他们所有人，如果仅有2-3%的稳定用户访问我们的站点，也可以有几百万的用户，你可以选择为他们的目标服务，并且还可以提供更多的额外的服务特性。</p>

<p>这个Idea的危险性在于当你向你的饲养宠物的朋友推荐时，他们是不会说『I would never use this』， 他们会说『是的，或许我会用这个网站买一些东西』。甚至当快要落地时，听到很多人的说法貌似正确的。但是他们其实根本就不会用它， 至少不会马上用它，但他们或许可以想象到其他人会想要他。总结下来整个用户的反应就是你只有0个用户。</p>

<p><strong>2.这些是好的（well）</strong></p>

<p>当一个项目落地时，至少有一些用户是真的需要（刚需）创业者用做出来的东西，并不是人们可以预见性的有朝一日会用它，但非常紧急使用它的用户在哪？  通常起步的用户群体是非常小的，理由很简单，如果一些需求有很大的用户群体需要，通常一个团队会全力以赴作好一个版本，并且或许这个版本已经存在。so 这就意味着你必须在这两者中做折中处理：为大多数中的少数还是少数中的大多数。选择后者，并不是所有的Idea都是好的创业Idea，但是几乎所有好创业的idea的都是那样的类型。</p>

<p>可以想象这样的一张图，有x，y两个维度，x代表用户对于你所做的事情需求（想要），y代表他们所想要的程度；一个创业者刚开始之初，并不能预估挖掘出用户的需求程度。这样你有两个选择，你可以选择一个要求广阔的领域切面的，或者是一个垂直领域，这样会很好。</p>

<p>想法放到场景中去学习是第一种类型。有很多人疯狂的对宠物主的社交网络十分的感兴趣。</p>

<p>几乎所有的好的Idea都属于第二种类型。例如微软、facebook，阿里巴巴，百度etc；</p>

<p>当你有一个Idea时候，要问问自己这两个问题，如果这些都回答不上来，说明这个Idea真的听糟糕的:</p>

<ul>
<li>谁会马上需要这个？</li>
<li>当他是一个重未被听说过甚至是蹩脚的版本时，是不是刚需？</li>
</ul>

<p>你的深层次的需求，需要做的就是不断优化你的深层次的需求，以及迭代效率；在实践中在不断聚焦和深度间，你会不断强化一种感觉，当你知道一个idea将透出更加烈的渗透到具体的社群中或者重塑你的用户。这样你会有一批核心用户。</p>

<p>然而要记住，需求模型是把一个好的idea更好的执行的必要条件，不是充分条件。如果扎克伯格直接针对哈佛的学生建立需求模型，他并不是一个好的idea。FaceBook为什么是一个好的Idea，因为它起步在一个小的市场中并且是很快的让别人知道；大学之间是十分相似的如果在Harvard，它会在任何一所大学都会有同样的效果，一旦覆盖了所有的大学生，你就会很简单的让更多的人加入进来；</p>

<p>其他的任何公司都是十分的相似，按照这样的方式进行下去。</p>

<p><strong>3.自修&amp;产品本身（self）</strong></p>

<p>你会怎样讲述一个通往这个Idea的路径（或者说方法）？你会怎样讲述这是一个将来会成长为巨头的微生物，or 就是一个在未来有利可图的产品？通常你做不到，airbnb创始人起初并没有意识到他们正在尝试的这个市场会这么大。起初他们有一个非常聚焦点的idea，就是让房东把地板腾出空间向外出租。他们并没有预料到他们的idea会扩张，这一切促使他自己慢慢的向上增长. 但是最初他们是完全专注的贴在这件事情上了。这点无论是比尔盖吃还是扎克伯格起初都是如此；</p>

<p>通常，当按照准出的想法设计路径，一开始效果特别明显。或者有时候可以看到有些办法并不是立竿见影。这是在YC的特性之一。但是你做的多么的好是有一定限度的，不管你有多少的经验。最重要的是去花时间理解关于最初想法的路径，基于那些很难看到的事实。</p>

<p>所以你不会 预测一个Idea的办法是否正确，不知道怎样在大量的idea间选择？这个事实是令人尴尬或者说是有趣的；如果你是一个合适的人，并且拥有正确的直觉。如果你站在一个变化十分迅速的前沿领域，一旦你有一个直觉说这个事情一定要去做，你有极大可能是正确的。</p>

<p>In Zen and the Art of Motorcycle Maintenance, Robert Pirsig says:</p>

<pre><code> You want to know how to paint a perfect painting?
 It's easy. Make yourself perfect and then just paint naturally.
</code></pre>

<p>直到我上了高中才知道那个办法. 我不确定这条建议，对于画画是否有用。但在创业这种情况是适用的。可以机械的认为，这个办法是成为有好的点子的那些人所必备的素质了。</p>

<p>成为一个领域的龙头并不意味着你不得不就是一个推动向前的一个人。你也可以成为前沿领域的一个用户。facebook 并不是因为扎克伯格是一个程序员而是因为他是一个重度的电脑用户。在2004年，如果你问大约40岁左右的人，是否愿意将他们的生活的半公开在网络上，这件事情对于他们来说很恐怖。但是对于Mark来说他的生活完全在网络上了已经，所以这是一件很自然的事情。</p>

<p>Paul Buchheim说过在一个极速变化的未来领域，展望未来. 结合来看是这样的：</p>

<p>展望未来，然后构建所缺失的东西。现在的很多的巨头刚开始，都不会像这样子描绘未来。甚至Apple，Yahoo，Google，Facebook起初都不是这样的公司。成长的已经超出了创始人刚开始公司的模样，因为他们是划时代的一笔。</p>

<p>如果你观察这个成功的路径，会发现他们脑海中早已经有这种想法，大致是脑海中早已经有的想法再加上外界刺激物的冲击的结果。外界的刺激物激发创业者开启他们公司的原因是他们的已有的经验早已经觉察到初露的机遇；</p>

<p>有个技巧就是你想要你的Idea获得尊重注意下这样的动词不要使用think up而是notice。在YC我们把那些在创始人自身经验以外可以自然生长的startup idea才叫做ideas，大多数的成功的startUp 都是以这种方式开始的；</p>

<p>这个路径似乎并不是你想要听到的那样。你或许在这之前一直期待有什么会想到好的startUp idea的秘密，相反我告诉你有想法的关键是用正确的方式去准备。听上去比较沮丧，但这是事实。如果要是有一个秘密那就是，在错误的道路上别走太远（在一个错误的例子上不是花费一年才发现，而是一周时间尽快的发现解决）。</p>

<p>如果你并没有站在一个快速变化的领域，你可以尝试去做一个。举个例子，任何人的智商都是相当的，或许可能去尝试编程用一年的时间里。既然一个成功的创业至少要花费你生命中的3-5年，那么用一年的时间作为投资还算合理。正好，你也可以同时寻找创业合伙人。</p>

<p>你不一定去学习变化非常快的编程这个领域，其他快速变化的领域也可以。但你没有必要学习到hack级别，他只要对未来有足够的前瞻就可以了。正如Marc Andreessen 所言，软件正在吃掉这个世界，接下来的十年仍然再继续。</p>

<p>知道怎么样去成为Hacker也意味着当你有ideas的时候，有能力去实现他。完全没有必要，但是那会成为你的优势。当你正在思考类似faceBook校园版的时候，这是一个很大的优势。从而你的思考会由『那是一个不错的Idea』变为「这是一个不错的Idea」。今晚我就会尝试建立一个初始版本。在你即是用户又是一个开发者的时候优势会更明显，因为迭代的版本和测试都是在一个脑袋中进行的。</p>

<p><strong>4.持续观察，持续注意（Noticing）（看得见）</strong></p>

<p>如果你刚好生活在未来的某个方面，留心到好的创业的idea的办法是寻找似乎缺失的东西。如果恰好你处在一个快速变化的领域，也许更好更准确的看到缺失的一环。创业的idea不会很明显的，让很多人看到。所以如果你想要发现好的idea，不仅仅要打开缺了什么？而且还要关闭其他的想法『例如：这个会变成一家大的公司么？』，有很多的时间申请测试这个。但是如果你正在考虑刚开始的idea，获取不紧要过滤掉很多好的idea，而且有可能造成你专注于坏的那一个。</p>

<p>发现大多缺失的东西会花费很多的时间才能看到。这时需要你不得不提醒你自己浸入式的从你身边寻找idea。</p>

<p>恩，你知道在那有一个idea的想法，在那么的问题中可能不只有一个答案。这是不可能的恰好的有一个技术的进程停止了。你必须相信接下来的几年中，人们会去建立更多的新事物，这样才会促使你去思考在问知到来我做了什么？</p>

<p>并且当这些问题得到解决的时候，他们将会似乎会更加清晰的进行回顾（复盘）。你需要做的是关闭那些阻碍你看穿事物本质的东西。最有力量的是简单的，并对这个世界的新生态信以为真。甚至完全的保持虚心（open-minded）对我们所做的。如果你停止去质疑一切事物，就不会有进步。</p>

<p>但是如果你正在寻找创业的idea，你可以尝试着去牺牲现有安于现状并且开始去质疑所有的新生事物。为什么要跳出盒子呢？难道是为了得到更多的email（信息）么，或者是因为在盒子外面很难得到好的信息么？为什么要得到这么多的email？人们通过你的email所要解决的是什么问题？有更好的方式解决这个问题么？为什么他比较难从盒子外获得email？阅读完email后为什么还会有那么多邮件围绕这你？针对这个收件箱的问题有最优的工具么？</p>

<p>对独有的事情进行关注，会点燃你的热情。把安逸的生活看做是理所当然的好处，不仅是让生活更便利，而且更加健康。如果你能预测到接下来50十年，我们的生活会有什么样的变化，而且现在还没有，你会发现当前的生活真的好美。这就是活在放下的快乐。</p>

<p>当你发现一个正确解决问题的方式时，你应该尝试清晰的将他描述出来，至少对于你是十分清晰的。当我们开创ViaWeb（被誉为最早的互联网的程序）的时候，所有线上的网店都是通过手动建立的，通过网站的设计者制作个性化的Html页面。很显然作为开发者那些网站都是通过软件自动生成的。</p>

<p>什么意思呢，就是说所想出来的idea要足够的奇怪，把一个问题看的提别清楚。建议是进程有多么的疯狂：你一定要致力于</p>

<p>把脑海中看到的东西，变的越加清晰。甚至可以表述给他人更清楚。</p>

<p>既然你需要放松你的大脑，或许最好的方式不是马上钻进问题中去，而是选择坐下来静静的去想问题。这最好的计划获许就是在背后默默的进行，并且不断的寻找似乎缺失的东西。任务越艰巨，越要有强烈的好奇心驱动，但是要不断的进行自我观察，并把一些走过的坑和异常情况记录下来。</p>

<p>给自己一段时间。你可以控制在你想到一个idea所投入的时间，但是你不能控制什么时候好的idea会点燃你，会什么时候开始撞击你。如果像比尔盖茨和保罗艾伦一开始就限制他们一个月内想出一个创业的idea，那么Altair会面世么？这恐怕很难保证。在 DropBox之前Drew Houston一直都工作在一个没有前景的idea上：那是进入预备创业考试的前奏。但是 DropBox是一个更加好的idea，有绝对的直觉并且与他们技能更加的匹配。</p>

<p>所从事的项目看起来似乎非常的cool，是一个能敲醒你投入到你的idea的好方式。如果你遇到了，那么你就会非常自热的朝向所缺失事物的方向建立所期待的东西。去建立一个已经存在的事物看起来似乎不是那么有趣。</p>

<p>正如如果你是想出一个idea那么他所创作出来的东西似乎会变的糟糕，从事的东西如果把它看做是一个可能被解雇的玩具，通常会创作出好的作品。当一件事物被描述成一个『玩具』的时候，那么这个idea就会被所有人有所期待，就会变得重要。它Cool，所以用户就会喜欢它，其他的都没关系。如果你所建立的用户喜爱的事物会影响未来人的生活，那么高于局外人去思考问题变得很重要。</p>

<p>Microcomputers似乎像一个玩具当Apple&amp;Microsoft刚开始起步时。我对那段历史有着古老的记忆，通常拥有Microcomputers（微型计算器）的人们都是一些Geeker，BackRub（Google早前的名字）似乎就是一个无足轻重的自然课，而FaceBook是一个大学毕业生之间交流的工具。</p>

<p>在YC ，当我们遇见到创业者所做的事情，让我急切地想了解它的全部的时候我会变得很兴奋。给我们积极的证明一个Idea是一件好事。</p>

<p>如果你能做到对很长的视野有一个期望，你可以把时间投入到建立未来事情上，把他变得更好。</p>

<p>Live in the future and build what seems interesting.</p>

<p><strong>5.学院派（School）</strong></p>

<p>我给学院派的建议是多去做，而不是每天想者去商学院学习。商学院的作用是把你正在做的事情，告诉你怎样做的更好。成功的创业者会很清楚这一点。在学校里你最需要做的是花费时间把你自己投入到未来的生活里，而大学是做这件事最好的机会。他是多么的浪费，牺牲掉这个解决创业刚开始最难那一部分的机会。容易的地方花时间学习就好了，难的部分是需要锻炼的。</p>

<p>有冲突的地方往往是Idea产出硕果累累的地方。如果你了解编程并且你也开始学习了其他领域，你很有可能看到一些软件可以解决的问题。事实上，再另外一个领域你很有可能发现双倍的问题。</p>

<ul>
<li>地区的居民并没有像有软件的地方通过软件解决了软件问题</li>
<li>既然你已经进入一个完全陌生的领域，甚至都不知道什么是一个原始状态（找到零点）。</li>
</ul>

<p>如果你是一名Cs major 并且想要创业，最好去上一节商学院的课，而不是在那研究演说和遗传学。或者更好的办法是上一届生物技术公司。CS majors 通常会得到夏季的工作，在一家硬件公司或者软件公司。 如果你想找到创业的idea，你或许可以在某个不相关的领域得到一分工作。</p>

<p>或者 不用参加任何其他的课程，只是去做事。微软和FaceBook都是在1月份开始起步的，这并不是偶然。在哈佛读书期间，学生是没有课程参加，因为他们必须为了期末的考试做准备。</p>

<p>但并不是让你必须去做一件可能会变成创业的事情。早期需要一个最佳的组合。就是构建事情。与其他同学一起更好。对于一所综合性的大学不仅是那里的课程，还有那里可以让你是一个可以让你沉浸在奇妙的想象当中的好地方。如果在项目上你与其他人一起合作，你就会完成你的产品，并不是停留在原始的想法上。当然如果你有原始的想法，也有原始的团队，从经验角度来讲，那是最好的组合了。</p>

<p>当心研究成果。如果一名大学生写下所有他的朋友们每天所用的东西，十分可能呈现出好的Idea。然而一名PhD 的学术论文是极其不可能做到这点，有几个原因，这个项目更多的考虑实在研究上，极少的可能是放在那些可以变成的创业的想法上的，主要的原因的把注意力放在研究上视野比较窄，更多的是让所研究的项目满意，而不是去解决的用户的问题。然而当学生们研究一些业余项目的时候，他们的重心会自主的朝向解决用户的问题走，获许甚至会增加额外的能量自由的从研究的限制中走出来。</p>]]></content:encoded></item><item><title><![CDATA[We Need《联盟》来！聊聊......]]></title><description><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/226425-d2cedd9f3e20936d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="We Need 联盟"></p>

<pre><code>    前几天在社交网站上看到一个作者提到了《联盟》这本书，感觉还不错作者是里德.霍夫曼(Linkin的创始人),就在网上下单了。没拿到书之前针对书想了几个问题：

    *联盟是什么？
    *为什么要联盟？
    *不联盟可以么？
    *以什么方式去联盟？为什么
    *联盟需要注意的是什么？
    *联盟的风险在哪？

    找了一个晚上一口气读完了这本书，拿到书时读起来发现写的是雇主与员工之间的联盟，诧异之后想了一下，这些理念完全可以推广开来，总结的有一点糙，后续有什么新的体会，白袍会及时更新，好了进入正题，：
    首先联盟是什么？是一种长期的保持互惠关系，价值对换的团队。它是区别与雇佣关系的，双方即使不存在雇佣关系，联盟关系依然存在。

    为什么要联盟？作者提到员工和雇员的关系建立在不诚实对话的基础上，这是现代雇佣关系的根本性脱节。并且公司要求员工向其做出承诺，但不会给员工相同的承诺，这个时候员工一般做两手准备一有机会就跳槽，进而作者提出自己的观点是互联网时代的雇佣关系，需要通过联盟重建信任和真诚。

    不联盟可以么？当然可以，不过这种模式更适合于处于稳定期的公司，在稳定期中公司不断壮大，以利用规模经济，改进流程。有些公司尤其是互联网公司变化速度很快，你无法保证稳定，所以我觉得与你身边的人建立联盟是一个不错的选择，这样看似约束力小，实则是将实现彼此的目标最大化，理由是联盟的原则就是互利互惠。

    以什么方式去联盟？</code></pre>]]></description><link>http://localhost:2368/we-need-lian-meng-lai-liao-liao/</link><guid isPermaLink="false">bb33f75c-23cb-4675-a382-ac1772b7c3f6</guid><dc:creator><![CDATA[Wilbur]]></dc:creator><pubDate>Thu, 04 Feb 2016 02:42:03 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/226425-d2cedd9f3e20936d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="We Need 联盟"></p>

<pre><code>    前几天在社交网站上看到一个作者提到了《联盟》这本书，感觉还不错作者是里德.霍夫曼(Linkin的创始人),就在网上下单了。没拿到书之前针对书想了几个问题：

    *联盟是什么？
    *为什么要联盟？
    *不联盟可以么？
    *以什么方式去联盟？为什么
    *联盟需要注意的是什么？
    *联盟的风险在哪？

    找了一个晚上一口气读完了这本书，拿到书时读起来发现写的是雇主与员工之间的联盟，诧异之后想了一下，这些理念完全可以推广开来，总结的有一点糙，后续有什么新的体会，白袍会及时更新，好了进入正题，：
    首先联盟是什么？是一种长期的保持互惠关系，价值对换的团队。它是区别与雇佣关系的，双方即使不存在雇佣关系，联盟关系依然存在。

    为什么要联盟？作者提到员工和雇员的关系建立在不诚实对话的基础上，这是现代雇佣关系的根本性脱节。并且公司要求员工向其做出承诺，但不会给员工相同的承诺，这个时候员工一般做两手准备一有机会就跳槽，进而作者提出自己的观点是互联网时代的雇佣关系，需要通过联盟重建信任和真诚。

    不联盟可以么？当然可以，不过这种模式更适合于处于稳定期的公司，在稳定期中公司不断壮大，以利用规模经济，改进流程。有些公司尤其是互联网公司变化速度很快，你无法保证稳定，所以我觉得与你身边的人建立联盟是一个不错的选择，这样看似约束力小，实则是将实现彼此的目标最大化，理由是联盟的原则就是互利互惠。

    以什么方式去联盟？为什么？

    雇主应该鼓励员工发展个人的人脉，勇于开拓实干，而不是到最后成为唯利是图的跳槽专业户。作为企业应该思考如何以有远见的方式促进员工发展，投资于长期关系。所强调的我们是一个团队，并不是一个家庭，保证整体价值观。书中建议的方式是任期制，设计出渐进性的方案。 职业生涯重新规划为一系列连续的任期【轮转期（锻炼长期的契合性），转变期（个性化的承诺：可以更加的明确自己的职业生涯规划所效力的公司），基础期（雇主和员工保持高度的一致性）】，三个期限的适用的最优组合取决于公司所处的具体市场环境，并且每一段任期都会从一段正式的谈话开始。对话模式的确定，通过公开透明建立信任基础，对话时需要做到的是：条理清晰，提前沟通议程，尽可能详尽具体。 

    里德.霍夫曼：在初创领英时，向有才华的员工提供了一份明确的协议，答应他们一般工作2-4年就将帮助其发展事业，作为领导人就要承认他们可能会离开这样的事实，这是建立联盟的前提，提倡一种共享，快速成长。

    协调：任期过程中需要协调有利于集体不一定有利于个人，有利于个人不一定有利于集体，所以站在这样的角度来看需要协调（协调员工与公司的目标和价值观）。

    硅谷真正的秘密是“以人为本”。开创型员工拥有着创始人思维，这种思维是推动改变，激动人心，出色的完成任务。有效的利用和留住这种人是合作中制胜的关键，这种人能在任何地方竞争，为事业创造积极的改变。

    领导的任务不是培养能人，而是认识到人们已有的才华并创造出让其发挥和成长的环境。

    联盟需要注意什么?

      *选择合适的盟友

      *双方都要为联盟做出表率，坦诚谈论自己的核心理想和价值观。

      *和盟友之间相处的方式

    联盟的风险在哪里？

    一旦后期关系弄得不好，可能会有些重要信息的泄露，联盟是利与害完全是一个硬币的两面，而有  的时候又必须联盟，所以即使不存在雇佣关系，也要维护好彼此的联盟关系，联盟一直都在。

    这本书在后面主要说的时人脉关系的维系和继承，我就不多说了，朋友们有时间的话可以读一读，希望有用，在这里大家可以多提看法，欢迎更多交流.....

                                                                          白袍君于北京
</code></pre>

<p>转载请注明：<strong>白袍君及文章链接</strong> 谢谢合作</p>]]></content:encoded></item><item><title><![CDATA[你所不了解的Android调色板]]></title><description><![CDATA[<p>最近在做Android项目中有这样一个需求：在首页的每个Feed有一张图片，图片上有文字等其它属性，上面的属性随着图片颜色的不同做出相应的变化，保证属性都能够看得清。        </p>

<p>解决方案：利用Android的Palette解析,官方文档这样介绍<a href="http://developer.android.com/reference/android/support/v7/graphics/Palette.html"><strong>Palette</strong></a>
   <img src="http://upload-images.jianshu.io/upload_images/226425-e95963dc68134a01.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240/q/100" alt="" title=""></p>

<p><strong>Palette为解析图片而来</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要知道的是上面涉及到的Vibrant、Muted、Muted Light等都有可能会提取不到，所以我们必须保证拿到一个值作为标准，这时我们很有必要知道Palette(调色板)的原理。     </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>调色板的简单原理</strong>：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PC机上 显示的图象是由一个个像素组成的，每个像素都有自己的颜色属性。在PC的显示系统中，像素的颜色是基于RGB模型的，每一个像素的颜色由红(B)、绿 (G)、蓝(B)</p>]]></description><link>http://localhost:2368/ni-suo-bu-liao-jie-de-androiddiao-se-ban/</link><guid isPermaLink="false">59433217-e2f2-466f-af24-2f39c904dbfc</guid><dc:creator><![CDATA[Wilbur]]></dc:creator><pubDate>Mon, 11 Jan 2016 06:19:24 GMT</pubDate><content:encoded><![CDATA[<p>最近在做Android项目中有这样一个需求：在首页的每个Feed有一张图片，图片上有文字等其它属性，上面的属性随着图片颜色的不同做出相应的变化，保证属性都能够看得清。        </p>

<p>解决方案：利用Android的Palette解析,官方文档这样介绍<a href="http://developer.android.com/reference/android/support/v7/graphics/Palette.html"><strong>Palette</strong></a>
   <img src="http://upload-images.jianshu.io/upload_images/226425-e95963dc68134a01.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240/q/100" alt="" title=""></p>

<p><strong>Palette为解析图片而来</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要知道的是上面涉及到的Vibrant、Muted、Muted Light等都有可能会提取不到，所以我们必须保证拿到一个值作为标准，这时我们很有必要知道Palette(调色板)的原理。     </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>调色板的简单原理</strong>：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PC机上 显示的图象是由一个个像素组成的，每个像素都有自己的颜色属性。在PC的显示系统中，像素的颜色是基于RGB模型的，每一个像素的颜色由红(B)、绿 (G)、蓝(B)三原色组合而成。每种原色用8位表示，这样一个的颜色就是24位的。以此推算，PC的SVGA适配器可以同时显示224约一千六百多万种颜色。24位的颜色通常被称作真彩色，用真彩色显示的图象可达到十分逼真的效果。但是，真彩色的显示需要大量的视频内存，一幅640×480的真彩色图象需要约1MB的视频内存。由于数据量大增，显示真彩色会使系统的整体性能迅速下降。原理图：
    <img src="http://upload-images.jianshu.io/upload_images/226425-8d4cd525d8907a2e.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/1240/q/100" alt="" title=""></p>

<pre><code>   调色板的工作原理:

   为了解决这个问题，计算机使用调色板来限制颜色的数目。调色板实际上是一个有256个表项的RGB颜色表，颜色表的每项是一个24位的RGB颜色值。使用调色板时，在视频内存中存储的不是的24位颜色值，而是调色板的4位或8位的索引。这样一来，显示器可同时显示的颜色被限制在256色以内，对系统资源的耗费大大降低了(不同时刻可以采用不同的调色板，因此可以扩展总共可以显示的颜色)。

   显示器可以被设置成16、256、64K、真彩色等显示模式，前两种模式需要调色板。在16或256色模式下，程序必须将想要显示的颜色正确地设置到调色板中，这样才能显示出预期的颜色。图11.1显示了调色板的工作原理。使用调色板的一个好处是不必改变视频内存中的值，只需改变调色板的颜色项就可快速地改变一幅图象的颜色或灰度。 

   除此之外还要知道的一个知识点是HSL值( H: Hue 色相 S：Saturation 饱和度 L Lightness 明度)其中L是其中L是从黑(0)到白(255)渐变。最后结合上面的知识点解决问题的思路也就有了:

     第一步：得到所要解析图片的BItmap

     第二步：缩小Bitmap（提升性能）

     第三步：异步方式提取Bitmap样本(Swatch)让样本的Color值尽量少，原因是我们主要想拿到HSL值中的Lightness明度值。

     第四步：获取明度值Lightness,一般大于75%文字偏向与黑色，否则白色。
</code></pre>

<p>最后配上代码:
<img src="http://upload-images.jianshu.io/upload_images/226425-3c18070ec210aece.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240/q/100" alt="" title=""> <br>
各位还请切磋赐教</p>

<p>2015/ 7/10 于北京   白袍君</p>

<p>转载请注明：<strong>白袍君及链接</strong></p>]]></content:encoded></item><item><title><![CDATA[成长需要对自己评估]]></title><description><![CDATA[<blockquote>
  <p>这篇文章快一年了,还是体会很深</p>
</blockquote>

<p>最近发现自己学习工作的效率比较低，然后不断的反思，发现成长中少了一环，缺少评估体系，让自己大脑保持清醒状态。简单的罗列几个问题问自己，发现在罗列过程中渐渐的清楚了:</p>

<p>1.最近说了什么？ <br>
2.最近做了什么？ <br>
3.最近想了什么？ <br>
4.最近大部分时间花在哪了？ <br>
5.最近改进了什么？ <br>
6.最近发现了什么？ <br>
7.最近哪些地方做的好，哪些地方做的不好？ <br>
8.现在在做什么？</p>

<p>试着思考下上面的问题，反思一下，发现一天做事慢慢效率提上来了，感觉回来了。</p>

<p>每天都是一份礼物，且行且珍惜！！！转载注明作者：<strong>白袍君</strong></p>

<pre><code>                                                                  白袍君  
                                                                  于北京2015/4/22早晨
</code></pre>]]></description><link>http://localhost:2368/cheng-chang-xu-yao-dui-zi-ji-ping-gu/</link><guid isPermaLink="false">0b3a4c2a-1f75-4916-8fbe-5fd2d2be296d</guid><dc:creator><![CDATA[Wilbur]]></dc:creator><pubDate>Mon, 11 Jan 2016 06:03:55 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>这篇文章快一年了,还是体会很深</p>
</blockquote>

<p>最近发现自己学习工作的效率比较低，然后不断的反思，发现成长中少了一环，缺少评估体系，让自己大脑保持清醒状态。简单的罗列几个问题问自己，发现在罗列过程中渐渐的清楚了:</p>

<p>1.最近说了什么？ <br>
2.最近做了什么？ <br>
3.最近想了什么？ <br>
4.最近大部分时间花在哪了？ <br>
5.最近改进了什么？ <br>
6.最近发现了什么？ <br>
7.最近哪些地方做的好，哪些地方做的不好？ <br>
8.现在在做什么？</p>

<p>试着思考下上面的问题，反思一下，发现一天做事慢慢效率提上来了，感觉回来了。</p>

<p>每天都是一份礼物，且行且珍惜！！！转载注明作者：<strong>白袍君</strong></p>

<pre><code>                                                                  白袍君  
                                                                  于北京2015/4/22早晨
</code></pre>]]></content:encoded></item><item><title><![CDATA[Andorid开发关于表情（Emoji）]]></title><description><![CDATA[<p>最近在做Android的评论加上表情，挺郁闷的，刚开始在网上找了下资源，发现大部分都是本地APP表情的展示,很少有通过网络之后在手机上显示表情的源码，后来在网上找了几份关于表情的代码，在此基础上进行了改进，最终解决了这个问题。</p>

<p>服务器是PHP,网络数据传输格式是json字符串，下面的简要的贴一下主要的代码：</p>

<p>需要注意的地方: 服务器端接收到的字段先解析不要直接使用json中的字段，然后再SetText，下面是接受服务器解析的方法，实际上就是去掉方括号的过程：</p>

<pre><code>ArrayList contentSpanArr = new ArrayList();

public void transText(String s,TextView tv){
   contentSpanArr.clear();
   tv.setText("");
   sortClassify(s);

   for(int i=0;i&lt;contentSpanArr.size();i++){
       String sa = contentSpanArr.get(i);
       if(sa.startsWith(</code></pre>]]></description><link>http://localhost:2368/andoridkai-fa-guan-yu-biao-qing-emoji/</link><guid isPermaLink="false">aab9593b-3de1-497f-8c12-444846d2f26e</guid><dc:creator><![CDATA[Wilbur]]></dc:creator><pubDate>Mon, 11 Jan 2016 06:02:52 GMT</pubDate><content:encoded><![CDATA[<p>最近在做Android的评论加上表情，挺郁闷的，刚开始在网上找了下资源，发现大部分都是本地APP表情的展示,很少有通过网络之后在手机上显示表情的源码，后来在网上找了几份关于表情的代码，在此基础上进行了改进，最终解决了这个问题。</p>

<p>服务器是PHP,网络数据传输格式是json字符串，下面的简要的贴一下主要的代码：</p>

<p>需要注意的地方: 服务器端接收到的字段先解析不要直接使用json中的字段，然后再SetText，下面是接受服务器解析的方法，实际上就是去掉方括号的过程：</p>

<pre><code>ArrayList contentSpanArr = new ArrayList();

public void transText(String s,TextView tv){
   contentSpanArr.clear();
   tv.setText("");
   sortClassify(s);

   for(int i=0;i&lt;contentSpanArr.size();i++){
       String sa = contentSpanArr.get(i);
       if(sa.startsWith("[")){
          boolean hasEmo = false;
          int j;
          for(j=0;j&lt;MsgFaceUtils.faceImgNames.length;j++){
             if(sa.equals(MsgFaceUtils.faceImgNames[j].trim())){
                hasEmo=true;
          SpannableString spannableString =          EmojiParser.getInstance(context).addFace(context, MsgFaceUtils.faceImgs[j],
                        MsgFaceUtils.faceImgNames[j]);
               tv.append(spannableString);
            }
        }
        if(!hasEmo){
            tv.append(sa);
        }
    }else{
        tv.append(sa);
    }
  }
}

public void sortClassify(String s){
     if (s.contains("[")) {
       String a1 = s.substring(0,s.indexOf("["));
       if(a1!=null&amp;&amp;a1.length()&gt;0){
          contentSpanArr.add(a1);
       }
       if(s.contains("]")){
          String z = s.substring(s.indexOf("["), s.indexOf("]")+1);
          contentSpanArr.add(z);
          String z1 = s.substring(s.indexOf("]")+1,s.length());
          sortClassify(z1);
       }else{
          contentSpanArr.add(s);
          return;
       }
     }else{
       contentSpanArr.add(s);
       return;
     } 
}
</code></pre>

<p>其它需要朋友自己在安装上<a href="https://github.com/RobertsChou/EmojiDemo">Github Demo</a>试一下就知道了，这个例子没有服务器是一个本地的，上面那个方法用到网络时才会用到。</p>

<p>If you have issue ,please by email: <strong>wenbohtone@gmail.com</strong></p>]]></content:encoded></item><item><title><![CDATA[话说Svn与Git的区别(以后别再问我了)]]></title><description><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;这篇主要是谈谈两者的区别，至于谁优谁劣看官自己思考吧！</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;这把第一条理解到位思想到位了做起来才会有的放矢，其他几条都是用的时候才能体会到</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;1) 最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local</p>]]></description><link>http://localhost:2368/hua-shuo-svnyu-gitde-qu-bie-yi-hou-bie-zai-wen-wo-liao/</link><guid isPermaLink="false">23a666fa-6605-48c0-996c-c62bdbef50f1</guid><dc:creator><![CDATA[Wilbur]]></dc:creator><pubDate>Mon, 04 Jan 2016 16:15:12 GMT</pubDate><content:encoded><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;这篇主要是谈谈两者的区别，至于谁优谁劣看官自己思考吧！</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;这把第一条理解到位思想到位了做起来才会有的放矢，其他几条都是用的时候才能体会到</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;1) 最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 2)Git把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 3) Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;4) Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 5) Git下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 6) 刚开始用时很狗血的一点，SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 7) 克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;8) 版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 9)分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来进行破坏工作（安检测试），那将会像传染病一样,你改一个分支，还得让其他人重新切分支重新下载，十分狗血。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可。无痛无痒。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;Git的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。最值得一提，我可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支。）</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 10)提交（Commit）在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。</p>

<p>最后总结一下：</p>

<p>SVN的特点是简单，只是需要一个放代码的地方时用是OK的。</p>

<p>Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。</p>

<p>参考: <br>
  <a href="http://blog.csdn.net/bruce_6/article/details/38299677">git和SVN的区别 - 生命在于折腾 - 博客频道 - CSDN.NET</a></p>

<p><a href="http://stackoverflow.com/questions/871/why-is-git-better-than-subversion">svn - Why is Git better than Subversion? - Stack Overflow</a></p>

<p>2015/7/11 于北京上地下午15：14完 </p>

<p>转载请注明作者：<a href="http://localhost:2368/hua-shuo-svnyu-gitde-qu-bie-yi-hou-bie-zai-wen-wo-liao/">白袍君</a></p>]]></content:encoded></item><item><title><![CDATA[建一个自己的博客  2016/01/03]]></title><description><![CDATA[<h3 id="firstblogonline">First Blog Online</h3>

<p>白袍君 <br>
主要是用来记录平时的所思所想,记录生活，日进一步。</p>]]></description><link>http://localhost:2368/2016-01-03/</link><guid isPermaLink="false">8744aa22-5352-4327-a7e2-6dd1643796bc</guid><dc:creator><![CDATA[Wilbur]]></dc:creator><pubDate>Sun, 03 Jan 2016 15:05:08 GMT</pubDate><content:encoded><![CDATA[<h3 id="firstblogonline">First Blog Online</h3>

<p>白袍君 <br>
主要是用来记录平时的所思所想,记录生活，日进一步。</p>]]></content:encoded></item></channel></rss>